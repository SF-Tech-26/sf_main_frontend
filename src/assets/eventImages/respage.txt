import React, { useRef, useEffect, useState, useCallback } from 'react';

// --- DATA: Updated to separate icon and title for cleaner display ---
const responsibilities = [
    { id: 1, icon: 'ðŸ“…', title: 'Project Oversight', description: 'Meticulous management of all project timelines and budget.', marginLeft: '5%' },
    { id: 2, icon: 'ðŸ‘¥', title: 'Team Leadership', description: 'Foster collaboration, mentor staff, resolve conflicts.', marginLeft: '55%' },
    { id: 3, icon: 'ðŸ—£ï¸', title: 'Client Communication', description: 'Primary liaison, transparency, manage stakeholder expectations.', marginLeft: '10%' },
    { id: 4, icon: 'ðŸ›¡ï¸', title: 'Quality Assurance', description: 'Establish quality standards and review processes.', marginLeft: '60%' },
    { id: 5, icon: 'âš ï¸', title: 'Risk Management', description: 'Identify roadblocks, assess impact, and mitigate risks.', marginLeft: '15%' },
    { id: 6, icon: 'ðŸ“ˆ', title: 'Strategic Planning', description: 'Contribute insights to long-term goals and future innovation.', marginLeft: '65%' },
];

// EMOJI POOL for random particles
const EMOJI_POOL = ['âœ¨', 'ðŸŒŸ', 'â„ï¸', 'ðŸ”¹', 'ðŸ”·', 'âš¡ï¸'];

// Keyframe Injection (A required technique for CSS animations in this single-file setup)
const injectKeyframes = () => {
    // NOTE: This injection remains PURE CSS because Tailwind doesn't dynamically create @keyframes
    if (!document.getElementById('dynamicKeyframes')) {
        const style = document.createElement('style');
        style.id = 'dynamicKeyframes';
        style.innerHTML = `
            @keyframes floatTitle {
                0% { transform: translateY(0); }
                50% { transform: translateY(-15px); }
                100% { transform: translateY(0); }
            }
            
            /* Emoji Pop and Float Animation */
            @keyframes popAndFloat {
                0% { opacity: 0; transform: translateY(0) scale(0.5); }
                20% { opacity: 1; transform: translateY(-10px) scale(1.1); }
                100% { opacity: 0; transform: translateY(-100px) scale(0.8); }
            }
        `;
        document.head.appendChild(style);
    }
};

// ==============================================================================
// 1. FAN SPINNER COMPONENT (Unchanged PURE CSS Dependency)
// ==============================================================================
const FanSpinner = React.memo(({ angle, isRightAligned }) => {
    // Uses fan-spinner and fan-blades PURE CSS classes for complex pseudo-elements (blades)
    return (
        <div className={`fan-spinner ${isRightAligned ? 'fan-right' : 'fan-left'}`}>
            <div className="fan-blades" style={{ transform: `rotate(${angle}deg)` }}>
                {/* Blades are created via PURE CSS pseudo-elements */}
            </div>
        </div>
    );
});


// ==============================================================================
// 2. TITLE PLATFORM COMPONENT (Tailwind)
// ==============================================================================
const TitlePlatform = () => (
    <header className="text-center pt-24 mx-auto max-w-6xl">
        {/* Tailwind Refactor: animation property uses the injected keyframes */}
        <div className="bg-slate-800/75 backdrop-blur-sm p-10 rounded-xl border border-cyan-200/20 mb-16 shadow-2xl shadow-cyan-400/40 animate-[floatTitle_6s_ease-in-out_infinite] relative z-50">
            <h1 className="text-5xl sm:text-6xl leading-tight font-extrabold text-blue-400">Responsibility</h1>
            <p className="mt-4 text-xl text-cyan-300 max-w-3xl mx-auto">Our six core responsibilities on a dynamic S-curve path.</p>
        </div>
    </header>
);

// ==============================================================================
// 3. TIMELINE STEP COMPONENT (Tailwind Refactored)
// ==============================================================================
const TimelineStep = React.forwardRef(({ step, isVisible, fanAngle }, ref) => {
    // Alternating positioning logic based on CSS margin-left styles
    const isRightAligned = step.marginLeft.includes('55%') || step.marginLeft.includes('60%') || step.marginLeft.includes('65%');

    // The transition and pop-out effect is handled via the is-visible class and transform styles
    const visibilityClass = isVisible
        ? 'opacity-100 translate-y-0 scale-100'
        : 'opacity-0 translate-y-12 scale-90';

    return (
        <div
            key={step.id}
            ref={ref}
            data-step-id={step.id}
            // Tailwind for styling, inline style for precise percentage alignment
            className={`timeline-step relative w-[90%] max-w-xl mb-32 z-10 transition-all duration-700 ease-[cubic-bezier(0.68,-0.55,0.265,1.55)] mx-auto md:w-[500px] ${visibilityClass}`}
            style={{ 
                // Using pure style for dynamic alignment based on data
                marginLeft: step.marginLeft,
                // Media query replacement (MD breakpoint only):
                // If it is Right Aligned and we are at md or larger, push to right (auto margin left, 5% margin right)
                // This is a simplified replacement for the :nth-child(even/odd) logic
                '@media (min-width: 768px)': isRightAligned ? { marginLeft: 'auto', marginRight: '5%' } : { marginLeft: '5%', marginRight: 'auto' }
            }}
        >

            {/* Fan Spinner */}
            <FanSpinner angle={fanAngle} isRightAligned={isRightAligned} />

            {/* Step Content (Tailwind Refactored) */}
            <div className="relative bg-slate-800/80 backdrop-blur-sm border-l-4 border-l-blue-500 p-6 rounded-lg shadow-xl hover:shadow-blue-500/70 transition-all duration-300">
                <h2 className="text-2xl font-bold text-blue-300">{step.title}</h2>
                <p className="mt-2 text-slate-300">{step.description}</p>

                {/* Step Marker (Tailwind Refactored) */}
                <div 
                    className="absolute w-10 h-10 leading-10 text-center text-2xl font-bold rounded-full bg-blue-500 text-white z-20 shadow-lg shadow-blue-500/50 border-4 border-slate-900"
                    // Inline style for precise positioning: -1.25rem (left/top) is -20px
                    style={{ left: '-1.25rem', top: '1.25rem' }}
                >
                    {step.icon} {/* Displays the emoji icon */}
                </div>
            </div>
        </div>
    );
});


// ==============================================================================
// 4. MAIN APP COMPONENT (The Orchestrator)
// ==============================================================================
const App = () => {
    const timelineRef = useRef(null);
    const curvePathRef = useRef(null);
    const stepsRefs = useRef([]);
    const scrollCounter = useRef(0);

    const [fanAngle, setFanAngle] = useState(0);
    const [isVisible, setIsVisible] = useState(new Array(responsibilities.length).fill(false));
    const [backgroundPosition, setBackgroundPosition] = useState(0);
    const [floatingEmojis, setFloatingEmojis] = useState([]);


    // --- EMOJI LOGIC (Unchanged) ---
    const popRandomEmoji = useCallback(() => {
        const container = document.body;
        const spawnRange = 250;
        const x = Math.random() * (container.clientWidth - spawnRange) + (spawnRange / 2);
        const y = window.scrollY + window.innerHeight / 2;

        const newEmoji = {
            id: Date.now() + Math.random(),
            emoji: EMOJI_POOL[Math.floor(Math.random() * EMOJI_POOL.length)],
            x: x,
            y: y,
        };

        setFloatingEmojis(prev => [...prev, newEmoji]);

        setTimeout(() => {
            setFloatingEmojis(prev => prev.filter(e => e.id !== newEmoji.id));
        }, 2100);
    }, []);
    // ------------------


    // Helper function to get the center point of a marker relative to the timeline container
    const getMarkerCenter = useCallback((stepEl, timelineRect) => {
        const marker = stepEl.querySelector('div:last-child'); // Target the step marker div
        if (!marker) return null;
        const rect = marker.getBoundingClientRect();
        return {
            x: rect.left + rect.width / 2 - timelineRect.left,
            y: rect.top + rect.height / 2 - timelineRect.top
        };
    }, []);

    // Recalculates and draws the S-Curve SVG path
    const updateCurve = useCallback(() => {
        const path = curvePathRef.current;
        const timeline = timelineRef.current;
        if (!path || !timeline || stepsRefs.current.length < 2) return;

        const timelineRect = timeline.getBoundingClientRect();
        let d = '';

        stepsRefs.current.forEach((step, i) => {
            const p = getMarkerCenter(step, timelineRect);
            if (!p) return;

            if (i === 0) {
                d = `M${p.x},${p.y} `;
            } else {
                const prev = getMarkerCenter(stepsRefs.current[i - 1], timelineRect);
                if (!prev) return;

                const controlX = i % 2 !== 0 ? prev.x + 100 : prev.x - 100;
                d += `Q${controlX},${prev.y + 10} ${p.x},${p.y} `;
            }
        });

        path.setAttribute('d', d);
        const total = path.getTotalLength();
        path.style.strokeDasharray = total;
        path.style.strokeDashoffset = total;
    }, [getMarkerCenter]);


    // Handles all scroll-driven effects (Path Reveal, Pop-Out, Parallax, Fan Spin)
    const handleScroll = useCallback(() => {
        const curve = curvePathRef.current;
        const timeline = timelineRef.current;
        if (!curve || !timeline) return;

        const scrollY = window.scrollY;
        const scrollDepth = scrollY - timeline.offsetTop;

        // --- 1. S-Curve Path Reveal ---
        const totalLength = curve.getTotalLength();
        const firstStep = stepsRefs.current[0];
        const lastStep = stepsRefs.current[stepsRefs.current.length - 1];

        if (firstStep && lastStep) {
            const REVEAL_SYNC_FACTOR = 0.7;
            const pathRevealScrollDepth = lastStep.offsetTop + lastStep.offsetHeight - firstStep.offsetTop;
            const pathLengthProgress = Math.min(1, Math.max(0, scrollDepth / (pathRevealScrollDepth * REVEAL_SYNC_FACTOR)));
            curve.style.strokeDashoffset = totalLength * (1 - pathLengthProgress);
        }

        // --- 2. Steps Pop-Out ---
        const newIsVisible = isVisible.slice();
        let changed = false;

        stepsRefs.current.forEach((step, i) => {
            const rect = step.getBoundingClientRect();
            // Trigger when element is 95% up from the bottom of the viewport
            const shouldBeVisible = rect.top < window.innerHeight * 0.95;

            if (shouldBeVisible !== newIsVisible[i]) {
                newIsVisible[i] = shouldBeVisible;
                changed = true;
            }
        });
        if (changed) {
            setIsVisible(newIsVisible);
        }

        // --- 3. Parallax Background & Leaving Screen Fix ---
        const maxScroll = document.body.scrollHeight - window.innerHeight;
        const imageTravelDistance = window.innerHeight * 2;
        const scrollRatio = window.scrollY / maxScroll;
        const bgPos = scrollRatio * imageTravelDistance * -1;
        setBackgroundPosition(bgPos);

        // --- 4. Fan Synchronization ---
        const fanAngle = scrollY * 0.7;
        setFanAngle(fanAngle);

        // --- 5. Random Emoji Pop Trigger ---
        scrollCounter.current += 1;
        if (scrollCounter.current % 10 === 0) { // Pop a new emoji every 10 scroll events
            popRandomEmoji();
        }

    }, [isVisible, popRandomEmoji]);

    // Setup and Cleanup Effects
    useEffect(() => {
        injectKeyframes();
        updateCurve();

        let ticking = false;
        const onScroll = () => {
            if (!ticking) {
                window.requestAnimationFrame(() => {
                    handleScroll();
                    ticking = false;
                });
                ticking = true;
            }
        };

        window.addEventListener('scroll', onScroll);
        window.addEventListener('resize', updateCurve);
        setTimeout(() => {
            onScroll();
            updateCurve();
        }, 100);

        return () => {
            window.removeEventListener('scroll', onScroll);
            window.removeEventListener('resize', updateCurve);
        };
    }, [updateCurve, handleScroll]);

    return (
        <div
            className="main-app-container font-sans bg-slate-900 text-slate-50 min-h-[400vh] overflow-x-hidden relative"
            // Inline style for dynamic background position and PURE CSS classes for the custom background image/grid.
            style={{ backgroundPosition: `center ${backgroundPosition}px` }}
        >
            <div className="content-wrap relative z-10">

                {/* 1. FLOATING EMOJIS LAYER (Tailwind Refactored) */}
                {floatingEmojis.map(e => (
                    <div
                        key={e.id}
                        className="absolute text-2xl pointer-events-none z-[100] animate-[popAndFloat_2s_forwards_ease-out]"
                        style={{
                            left: `${e.x}px`,
                            top: `${e.y}px`,
                        }}
                    >
                        {e.emoji}
                    </div>
                ))}

                {/* 2. TITLE PLATFORM COMPONENT */}
                <TitlePlatform />

                {/* Timeline Container (Tailwind Refactored) */}
                <div id="timeline" ref={timelineRef} className="relative py-5 w-full max-w-7xl mx-auto">

                    {/* SVG Curve Line (Tailwind Refactored) */}
                    <svg className="absolute top-0 left-0 w-full h-full z-10 overflow-visible pointer-events-none" xmlns="http://www.w3.org/2000/svg">
                        <path
                            id="curvePath"
                            ref={curvePathRef}
                            // Tailwind Refactor
                            className="fill-none stroke-cyan-300 stroke-[4px] stroke-round drop-shadow-lg drop-shadow-cyan-300 transition-[stroke-dashoffset] duration-300 linear"
                            d=""
                        />
                    </svg>

                    {/* 3. TIMELINE STEP COMPONENTS (Mapped) */}
                    {responsibilities.map((step, i) => (
                        <TimelineStep
                            key={step.id}
                            ref={el => stepsRefs.current[i] = el}
                            step={step}
                            isVisible={isVisible[i]}
                            fanAngle={fanAngle}
                        />
                    ))}
                </div>
            </div>

            {/* --- PURE CSS STYLES (REQUIRED FOR COMPLEX FEATURES) --- */}
            <style>{`
                /* Aurora Borealis Grid Parallax (Requires PURE CSS for complex gradients/size/attachment) */
                .main-app-container {
                    /* Original complex gradient and grid setup */
                    background-image:
                        linear-gradient(to bottom, transparent 0%, rgba(59,130,246, 0.3) 10%, transparent 40%, rgba(103,232,249, 0.3) 60%, transparent 90%),
                        linear-gradient(to right, rgba(59,130,246, 0.1) 1px, transparent 1px),
                        linear-gradient(to bottom, rgba(59,130,246, 0.1) 1px, transparent 1px);
                    background-size: 100% 300vh, 50px 50px, 50px 50px;
                    background-repeat: no-repeat, repeat, repeat;
                    background-attachment: fixed;
                    transition: background-position 0.1s ease-out;
                }
                
                /* Fan Styles (Requires PURE CSS for pseudo-elements) */
                .fan-spinner { position: absolute; width: 60px; height: 60px; top: 50%; transform: translateY(-50%); opacity: 0.8; z-index: 10; pointer-events: none; }
                .fan-left { left: -100px; right: auto; }
                .fan-right { right: -100px; left: auto; }
                .fan-blades { width: 100%; height: 100%; position: relative; border-radius: 50%; transition: transform 0.01s linear; border: 4px solid #3b82f6; box-shadow: 0 0 10px #3b82f6; }
                .fan-blades::before, .fan-blades::after {
                    content: ''; position: absolute; top: 50%; left: 50%; width: 60px; height: 8px; margin-top: -4px; margin-left: -30px; 
                    background-color: #67e8f9; box-shadow: 0 0 10px #67e8f9; border-radius: 4px;
                }
                .fan-blades::after { transform: rotate(90deg); }
            `}</style>
        </div>
    );
};

export default App;